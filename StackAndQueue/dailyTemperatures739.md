# 距离下一次升温的天数间隔

[toc]

### 原题

根据每日 气温 列表，请重新生成一个列表，对应位置的输入是你需要再等待多久温度才会升高超过该日的天数。如果之后都不会升高，请在该位置用 0 来代替。

例如，给定一个列表 temperatures = [73, 74, 75, 71, 69, 72, 76, 73]，你的输出应该是 [1, 1, 4, 2, 1, 1, 0, 0]。

提示：气温 列表长度的范围是 [1, 30000]。每个气温的值的均为华氏度，都是在 [30, 100] 范围内的整数。

来源：力扣（LeetCode）
[链接](https://leetcode-cn.com/problems/daily-temperatures)：https://leetcode-cn.com/problems/daily-temperatures

----

### 三种解法

##### 1.暴力法(我的解法)

```java
public int[] dailyTemperatures(int[] T) {
        int[] result = new int[T.length];
        for (int i = 0; i < T.length; i++) {
            for (int j = i + 1; j < T.length; j++) {
                if (T[j] > T[i]) {
                    result[i] = j - i;
                    break;
                }
            }
        }
        return result;
    }
```

思路分析：

* 暴力法很简单，对于当日温度，都遍历一次其后的温度，直到找到某天温度比它高，由索引计算天数间隔即可。
* 存放答案需要一个数组，所以空间复杂度为$O(n)$；可以想象最坏的情况温度是降序排序的，需要两层遍历，所以时间复杂度是$O(n^2)$的。

运行结果：
* 执行用时 :243 ms, 在所有 Java 提交中击败了19.25%的用户
* 内存消耗 :42.4 MB, 在所有 Java 提交中击败了57.45%的用户
##### 2.从末尾遍历，并使用栈存放有效温度（官方标答）

```java
public int[] dailyTemperatures2(int[] T) {
        int[] result = new int[T.length];
        Stack<Integer> stack = new Stack<>(); // 用来存放有效温度的索引
        for (int i = T.length - 1; i >= 0; --i) {
            while (!stack.isEmpty() && T[i] >= T[stack.peek()]) // 将冗余信息删去，如果靠后的日子温度比当前低，他完全没有意义记录
                stack.pop();
            result[i] = stack.isEmpty() ? 0 : stack.peek() - i; // 栈中无元素说明当日之后温度没有比其高的！
            stack.push(i);
        }
        return result;
    }
```

思路分析：

* 要确定当日之后间隔多少天后可以出现更高的温度，需要当日之后的信息。要得到前面的结果，需要知道其后所有的信息，那么从后遍历是否可以更快捷。
* 以题目所给的例子temperatures = [73, 74, 75, 71, 69, 72, 76, 73]来看。倒数第一天的温度（73）低于倒数第二天的温度（76），对于倒数第二天以前的日子，其后最近出现更高温度的日子，最远为倒数第二天。所以此时倒数第一天的温度没有任何记录价值。
* 倒数第三天温度（72）小于倒数第二天温度（76），那么对于倒数第三天以前的日子，其后最近出现更高温度的日子，最远可能为倒数第三天也可能为倒数第二天，所以此时这两天的温度都有记录价值。
* 以此类推，我们可以看到第三天的温度（75），仅低于倒数第二天的温度，则这两天之间的温度对于第一天与第二天没有任何意义。因为第一天，第二天后最近出现更高温度的日子如果不在第三天出现，那么更高的温度也只有倒数第二天了。
* 所以，在从后往前的遍历中，发现了更高的温度，则较低的已记录温度则成为冗余信息。本问题中，要给出的答案是天数间隔，所以记录天数的索引更有用，通过索引也能直接得到当日气温。
* 用栈来记录天数索引，这样从后往前遍历的过程中，有用靠后的较高温信息（通过索引记录）就能存放在栈底，有用靠前一点较小的温度信息放在靠近栈顶的地方。
* 每个元素最多一次入栈一次出栈，所以时间复杂度为$O(n)$。空间复杂度为$O(n+w)$,n为答案数组，w为栈中存放的索引。

代码解释：

* 4~9行，从后往前的遍历，得到每一天题目要求的答案。
* 5~6行，当日温度与其后面有效温度(栈非空`!stack.isEmpty()`)进行对比，如果`T[i] >= T[stack.peek()`当日温度更高，删去靠后的较低温度`stack.pop();`
* 7行，栈为空说明当日后面没有更高温度，答案为0否则记录为日期间隔。
* 8行，当日温度对于前面的日子一定为有价值的温度，所以压入栈中。

运行结果：
* 执行用时 :75 ms, 在所有 Java 提交中击败了49.43%的用户
* 内存消耗 :43.7 MB, 在所有 Java 提交中击败了14.47%的用户
##### 3.从末尾遍历，并用数组记录距离下一个有效温度的间距（官方标答）

```java
 public int[] dailyTemperatures3(int[] T) {
        int[] result = new int[T.length];
        for (int i = T.length - 2; i >= 0; i--) {
            // result[j]的意义是 j这一天之后多少天的温度比j这天高 result[j]+j即为比j温度高的最邻近的一天。这样就省略了比较比j这一天温度低的日子
            for (int j = i + 1; j < T.length; j += result[j]) { // j的值代表温度可能比i这天温度高的 天数
                if (T[i] < T[j]) {
                    result[i] = j - i;
                    break;
                } else if (result[j] == 0) { // 在i这一天温度>=j这一天温度时，如果result[j]==0意味着在j这天之后没有哪天温度比其更高
                    result[i] = 0; // 所以i这一天之后也没有任何温度比其高了 result[i]置为0
                    break;
                }
            }
        }
        return result;
    }
```

思路分析：

* 大方向与方法二相同，处于同样的目的，从后往前遍历。不过`result[i]`的现实意义就是可用信息，意义是`i`这一天之后多少天的温度比`i`这天高。 `result[i]+i`即为比`i`温度高的最邻近的靠后的一天。
* 对于`i`这一天，要找到那一天比它温度更高，就只需要先和`j=i+1`这一天比，如果`i`这一天温度高于`j=i+1`这一天，则去与比`j`这一天温度更高的下一个温度`j=result[j]+j`。直到找到一个比它本身温度更高的天数，记录`result[i]=`的值。
* 如果一直没有找到更高的温度，即遇到`result[j] == 0`的情况，说明`j`这一天已经为除当日以外的最高温，但依旧没有当日高，将`result[i]`记录为0。

代码解释：

* 第3行，循环初始条件为`int i = T.length - 2`,因为最后一天之后不会有更高温度了`result[T.length -1]=0`是默认值。
* 第5行，` j += result[j]`，使`j`一直为下一个可能更高温度的天数索引，每次`j`的变化都跳过了中间的冗余信息。

运行结果：
* 执行用时 :7 ms, 在所有 Java 提交中击败了86.58%的用户
* 内存消耗 :42.2 MB, 在所有 Java 提交中击败了67.20%的用户

### 反思

遍历的方式值得思考。要确定当前的信息，需要当日之后所有有用信息，所以从后面开始遍历。

例如，要**知道一个长字符串是否为回文，需要知道从对称中心向外每个对称位置的信息，也可以从对称中心往左右两边遍历元素**。